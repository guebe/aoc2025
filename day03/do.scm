(define example '(987654321111111 811111111111119 234234234234278 818181911112111))
(load "input.scm")
(load "srfi-1.scm")

(define (number->digits number)
  (unfold-right (lambda (n) (= n 0))
		(lambda (n) (modulo n 10))
		(lambda (n) (quotient n 10))
		number))

(define (max-joltage number k)
  (define (recur digits k)
    (if (= k 0)
        '()
	(let* ((window (take digits (- (length digits) k -1)))
	       (best (fold (lambda (n acc) (if (> n acc) n acc)) 0 window))
	       (rest (cdr (drop-while (lambda (x) (not (= x best))) digits))))
	  (cons best (recur rest (- k 1))))))
  (recur (number->digits number) k))

(define (add-digits l1 l2)
  (define (add-rev r1 r2 carry)
    (if (and (null? r1) (null? r2))
        (if (zero? carry)
	    '()
	    (cons carry '()))
	(let ((a (if (null? r1) 0 (car r1)))
	      (b (if (null? r2) 0 (car r2)))
	      (rest1 (if (null? r1) '() (cdr r1)))
	      (rest2 (if (null? r2) '() (cdr r2))))
	  (let ((sum (+ a b carry)))
	    (cons (modulo sum 10)
		  (add-rev rest1 rest2 (quotient sum 10)))))))
  (reverse (add-rev (reverse l1) (reverse l2) 0)))

(define (sum-joltage in k)
  (fold (lambda (n acc) (add-digits acc (max-joltage n k))) '() in))

(define (display-digits digits)
  (for-each (lambda (d) (display d)) digits))

(display-digits (sum-joltage example 2)) (newline)
(display-digits (sum-joltage input 2)) (newline)
(display-digits (sum-joltage example 12)) (newline)
(display-digits (sum-joltage input 12)) (newline)
